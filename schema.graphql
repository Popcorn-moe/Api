scalar Url
scalar Date
scalar Time
scalar DateTime
scalar Upload

type Anime implements Dated {
	id: ID!
	names: [String!]!
	authors: [Author!]!
	tags: [Tag!]!
	status: AnimeStatus
	medias: [Media!]!
	season: [Season!]!
	# An url
	cover: String
	# An url
	background: String

	release_date: DateTime
	edit_date: DateTime!
	posted_date: DateTime!
}

enum AnimeStatus {
	PENDING
	FINISHED
	NOT_STARTED
}

type Author {
	id: ID!
	name: String!
	picture: Url
	bio: String!
	organisation: Boolean!
	animes(limit: Int, sort: Sort): [Anime!]!
}

type Tag {
	id: ID!
	name: String!
	desc: String!
	color: String!
}

type Media implements Dated {
	id: ID!
	comments: [Comment!]!
	type: MediaType!
	rate: Float!
	release_date: DateTime
	edit_date: DateTime!
	posted_date: DateTime!
}

enum MediaType {
	EPISODE
	TRAILER
	SONG
	FILM
}

type Season implements Dated {
	name: String!
	episodes: [Media!]!
	release_date: DateTime
	edit_date: DateTime!
	posted_date: DateTime!
}

type Comment {
	id: ID!
	user: User!
	content: String!
	posted: DateTime!
	edited: DateTime
}

interface Dated {
	release_date: DateTime
	edit_date: DateTime!
	posted_date: DateTime!
}

type User {
	id: ID!
	login: String!
	email: String!
	group: UserGroup!
	newsletter: Boolean!
	account_registered: Boolean!
	playlists: [Playlist!]!

	# An url
	avatar: String
	ratings: [AnimeRating!]!
	rating_for(id: ID!): AnimeRating
}

type Playlist {
    id: ID!
    name: String!
    type: PlaylistType!
    medias: [Media!]!
}

enum PlaylistType {
    NORMAL,
    HISTORY,
    FOLLOWS
}

enum UserGroup {
	ADMIN,
	MODERATOR,
	VIEWER
}

type AnimeRating {
	anime: Anime!
	rating: Float!
}

type News {
	id: ID!
	name: String!
	author: User!
	content: String!
	posted_date: DateTime!
}

type Query {
	me: User
	tags: [Tag!]!
	users: [User!]!
	authors: [Author!]!
	animes(limit: Int, sort: Sort = NONE): [Anime!]
	author(id: ID!): Author
	anime(id: ID!): Anime
	anime(name: String!): Anime
	tag(id: ID!): Tag
	media(id: ID!): Media
	news: [News!]!
	_news(id: ID!): News
}

type Result {
	error: String
}

input NewsInput {
	name: String!
	content: String!
	author: ID!
}

input NewsUpdate {
	name: String
	content: String
	author: ID
}

input AnimeInput {
	names: [String!]
	authors: [ID!]
	tags: [ID!]
	status: AnimeStatus
	medias: [ID!]
	season: [ID!]
	cover: Upload
	background: Upload
	desc: String
	release_date: Date
}

input TagInput {
	name: String!
	desc: String!
	color: String!
}

input TagUpdate {
	name: String
	desc: String
	color: String
}

input AuthorInput {
	name: String!
	picture: Upload
	bio: String!
	organisation: Boolean!
}

input AuthorUpdate {
	name: String
	picture: Upload
	bio: String
	organisation: Boolean
}

type Mutation {
	addNews(news: NewsInput!): ID!
	deleteNews(id: ID!): ID!
	updateNews(id: ID!, news: NewsInput!): ID!
	setAvatar(file: Upload!): Result!
	addAnime(anime: AnimeInput!): ID!
	updateAnime(id: ID!, anime: AnimeInput!): ID!
	addTag(tag: TagInput!): ID!
	updateTag(id: ID!, tag: TagUpdate!): ID!
	deleteTag(id: ID!): ID!
	addAuthor(author: AuthorInput!): ID!
	updateAuthor(id: ID!, author: AuthorUpdate!): ID!
	deleteAuthor(id: ID!): ID!
}

enum Sort {
	NONE,
	ASC,
	DSC
}

schema {
	query: Query
	mutation: Mutation
}
